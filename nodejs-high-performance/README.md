# Node.js High Performance

by Diogo Resende

# Ch. 01 소개 및 컴포지션

- 성능을 높이는 일은 많은 요소들과 연결돼 매우 어렵다.
- 사용하는 언어의 단점을 알고 있을 때, 최선의 성과를 만들어낼 수 있다.
- JS 는 네트워크나 디스크에 접속할 방법이 없다. 대신, Node.js 는 libuv 를 사용해 논블로킹 I/O 모델을 통해 제공한다. 이 I/O 모델의 API 에는 버퍼와 스트림이 존재한다.
  - 버퍼: 이진 데이터 형식을 JSON 같은 다른 형식으로 전환할 때 유용하다.
  - 스트림: 네트워크 모델과 유사한 모듈이다. readable, writable, duplex, 그리고 transform 스트림을 생성할 수 있는 기본 클래스에 접근할 수 있다.

## 성능 분석 (프로파일링)

- 성능이란 정해진 기간과 리소스에서 수행이 완료되는 일의 양을 의미한다.
- 성능 분석을 위해 성능 목표에 따라 여러가지 측정 기준 (메트릭)을 사용할 수 있다.
- Node.js 의 우수성은 I/O 작업에 의해 애플리케이션이 블로킹되지 않는다는 점이다.

## 모니터링

- 모니터링을 통해 플랫폼이 동작을 멈추거나 다음에 동작을 멈출 위치를 알 수 있다.

## 고성능 확보

- 고성능은 개발 계획에서부터 시작된다.
- 사용자 수의 증가는 분산 아키텍처의 필요성을 높이거나, 최소한 다수의 인스턴스를 통해 부하를 분산시킬 것을 요구한다.
- 대부분의 애플리케이션은 시간이 지날수록 그 성능(처리 능력)이 떨어진다. 이는 데이터베이스와 디스크의 데이터 크기가 증가하기 때문이다.
- 지리적으로 분산된 서버들은 클라이언트로부터 더 가까운 곳에서 동작해 더 좋은 성능을 제공할 수 있다.

## 테스트와 벤치마킹

- 애플리케이션이 특정 환경에서 정상적으로 동작하는지 확인하는 방법이다.
- 성능을 분석하면 애플리케이션의 병목 구간을 탐지할 수 있다.
- 대표적인 예시로
  - [benchmarkjs](http://benchmarkjs.com)
  - [ben](https://github.com/substack/node-ben)
- 부하 테스트는 가장 단순한 형태의 벤치마킹이다.
  - 특정 부하에서 애플리케이션의 성능이 어느정도인지 확인할 수 있다.
  - 애플리케이션에서 1초에 받아들일 수 있는 연결의 수나 처리할 수 있는 트래픽의 바이트 수를 확인할 수 있다.
- 유지(Soak) 테스트는 애플리케이션의 성능이 유지되는 시간을 확인하기 위해 수행된다.
  - 이 테스트는 시간이 지나면서 성능이 저하되는 애플리케이션의 반응성을 분석할 때 필요하다.
  - 시간이 지나면서 메모리 누수에 따른 성능 저하가 발생하는 애플리케이션의 메모리 누수를 확인하는 데 유용하게 사용된다.
- 스파이크 테스트는 부하가 갑자기 증가하는 상황에서 애플리케이션의 반응과 성능을 확인하기 위해 수행된다.

## 애플리케이션 컴포지션

- 컴포지션은 애플리케이션의 유지, 보수, 개발, 이해가 용이하게 애플리케이션을 작은 단위로 나누는 방식을 말한다.
- 코드 나누기
  - 코드는 항상 작은 단위로 나눠야 한다.
  - 5KB 보다 큰 파일은 나누기를 고려애햐 한다.
- 함수 규칙 사용
  - [JSCS](http://jscs.info) 참조
  - 콜백으로 사용되는 클로저 함수인 경우 반드시 함수명을 명시해야 한다.
    - 이를 통해 코드가 실행 중 멈춰도 스택을 추적하는 과정에서 이를 구분할 수 있다.
    - 또한 새로운 개발자가 함수의 목적을 빨리 이해하는 데 도움이 된다.
  - 조건 분기를 중첩해 사용하지 말고, 반환은 가능한 빠르게 한다.
  - 함수를 작고 단순하게 작성하자.

# Ch. 02 개발 패턴

## 패펀이란?

- 패턴은 개념적인 것으로, 일반적인 프로그래밍 문제들에 대한 재사용 가능한 해결책을 말한다.
- 모든 패턴에는 장점과 단점이 혼재되어 있다.
- 일반적인 안티 패턴
  - 반복: 과도한 양의 코드를 반복하지 말아야 한다.
  - 최고라고 생각되는 새로운 솔루션 만들기: NPM 을 이용해라
  - 오류 기반의 코드 개발: 오류의 모든 유형에 대한 코드를 작성하려 하지 말고, 일반적인 것들만 처리하도록 만들자.
  - 시행착오를 통한 프로그래밍

## Node.js 패턴

- 모든 **스트림**은 **이벤트 전송자 (event emitter)**가 확장된 것이다.
  - 가장 기본적인 형태에서 스트림은 버퍼에 있는 데이터 이벤트를 내보내는 과정이다.
  - 이벤트, 스트림 그리고 버퍼가 이벤트 주도 아키텍처의 좋은 예시이다.
- `fs` 스트림을 사용해 `http` 스트림에 이어주는 것처럼 서로 다른 유형의 스트림도 연결될 수 있다.
  - 이러한 사용성을 통해 애플리케이션 내의 불필요한 메모리 할당을 피하면서 플랫폼으로 작업을 전달할 수 있다.
- 버퍼는 문자열 인코딩에 의해 문자열이 깨질 수 있는 데이터를 조작할 때 반드시 사용해야 하는 객체다.

## 패턴 유형

### 아키텍처 패턴

- 소프트웨어 프레임워크 내부에 구현된다.
- 프론트 컨트롤러 패턴
  - 들어오는 모든 요청을 유일한 컨트롤러에서 처리하는 형태이다.
  - 공통 라이브러리를 로드하는 단일 진입점이 존재하며, 이러한 공통 라이브러리에는 데이터 접근, 세션 관리, 각 요청에 대한 개별 컨트롤러 등이 있다.
  - 데이터베이스 접근, 세션 관리, 접근 및 에러 로깅, 일반적 접근, 권한, 어카운팅 등과 같은 일반적인 작업을 처리한ㄴ 중앙점이 존재한다.
  - 코드 반복을 많이 줄여준다.
  - 보안 취약점이 발견되는 경우 단일 진입점이 복수 진입점보다 봉쇄가 용이하기 때문에 보안 측면에서도 유리하다.
- Model-View-Controller
  - 애플리케이션 컴포넌트를 모델, 뷰, 그리고 컨트롤러로 나눈다.
  - 모델은 데이터 구조나 정보 로직을 의미한다. 예를들어 데이터베이스의 테이블이 될 수도 있다.
  - 뷰는 시각적 표현으로, 사용자 인터페이스를 의미한다.
  - 사용자가 뷰에서 동작을 수행할 때마다 컨트롤러에서 실제로 모델을 조작한다.
- 액티브 레코드 패턴
  - 단순 데이터 객체를 제공함으로써 관계형 데이터에 접근할 때 사용되는 추상적인 레이어다.
  - 이 객체를 조작하는 것으로 데이터베이스의 변경이 유발될 수 있는데, 이때 개발자는 애플리케이션이 사용하고 있는 데이터베이스의 유형을 알 필요가 없다.
    - 테이블이나 뷰는 클래스에 매핑된다.
    - 열을 인스턴스에 매핑된다.
    - 외래 키는 인스턴스를 참조해 처리된다.
  - 이 패턴은 두 가지 이유로 비판받는다.
    - 애플리케이션과 데이터 사이의 추상화 계층이 있기 때문에 성능을 많이 떨어뜨린다. 하지만 이를 통해 데이터 집중 애플리케이션에서의 메모리 누수를 개선할 수 있다.
    - 데이터 객체와 데이터베이스 사이의 강한 결합은 실제 데이터베이스를 적절히 테스트하는 것을 어렵게 만든다.
- 서비스 로케이터 패턴
  - 중앙 레지스트리를 사용해 서비스의 접근을 추상화하는 개념이다.
  - 중앙 레지스트리는 서비스 로케이터라고 불리며 서비스를 등록하고 각 서비스의 접근 메소드를 알려준다.
  - 애플리케이션의 확장성과 적응성이 주어진다.
  - 작업 부하에 대한 적응을 가능하게 한다.
    - 만약 동일한 서비스에서 다수의 인스턴스가 서버에 걸쳐 존재할 경우, 이 로케이터는 인스턴스 접근을 회전시켜 더 많은 인스턴스에서 더 많은 부하를 처리할 수 있도록 해준다.
  - 성능 개선 또는 버그 수정을 위해 서비스 등록을 해제하거나 새로운 레지스터를 등록하는 것을 가능하게 함으로써 서버 정지 시간을 0으로 유지할 수 있다.
  - 단일 문제점이 될 수 있는 취약점이 존재한다.
- 이벤트 주도 패턴
  - 이벤트의 생산 및 소비를 촉진시키는 패턴이다.
  - 프로그래밍 로직이 이벤트에 반응하도록 만든다.
  - 이벤트는 상태 변경을 의미한다. 예를들어 네트워크 연결이 생성되고, 데이터를 전달받고, 파일 처리가 종료되는 것들을 말한다.
  - 소비자라고 불리는 이벤트 감지 객체는 생산자인 해당 이벤트 이미터에 리스너(수신 대기자)를 등록한다.
  - 생산자 객체가 이벤트에 대한 상태 변화를 감지하면, 소비자 객체에 이벤트가 발생했음을 알린다.

### 생성 패턴

- 개발자가 새로운 데이터나 객체를 생성하기 위해 상요하는 패턴이다.
- 객체를 초기화하거나 기존의 것을 재사용할 때 선택할 수 있는 유연성을 애플리케이션에 더해준다.
- 팩토리 메소드 패턴
  - 특정 클래스로부터 애플리케이션을 추상화하고 새로운 객체를 생서하기 위해 사용된다.
  - 필요에 따라 생성 로직이 다른 서브클래스에서 처리되기도 한다.
  - 데이터베이스 연결이나 다른 데이터 정보 서비스 접근은 이 패턴을 사용하기에 좋은 경우이다.
- 지연 초기화 패턴
  - 복잡한 계산을 하거나 객체를 생성하는 것을 지연시킬 때 사용된다.
  - 팩토리 메소드와 함께 사용되며, 인스턴스를 팩토리 함수가 호출된 뒤에 저장해 함수가 한 번 더 호출할 때 해당 인스턴스를 반환하도록 할 때 쓰인다.
  - 이는 단일체를 얻는 또 다른 패턴이다
- 단일체 패턴
  - 작업을 효과적으로 하기 위해 애플리케이션에서 단일 객체 인스턴스가 요구될 때 사용된다.
  - 만약 이미 만들어진 메소드가 있다면 그것을 반환한다.
  - 이 방법은 웹 애플리케이션이 매 요청이 들어올 때마다 데이터베이스에 연결하는 것을 방지할 수 있기 때문에 매우 중요하다.
  - 액티브 레코드 패턴에서도 사용된다. 다수의 컴포넌트가 동일한 열을 ㅍ리요로 할 때, 각기 다른 객체를 반환하는 대신 하나의 객체를 반환할 수 있다.
- 빌더 패턴
  - 다른 클래스의 인스턴스를 만드는 클래스다.
  - 보통 팩토리 패턴에서 시작하여 빌더 패턴으로 발전된다.
  - 빌더 기반의 클래스들은 대개 복잡하기 때문에 빌더에서 직접 이 복잡함을 처리하기 위해 더 단순한 메소드를 공개하거나 요구에 맞게 개선한다.
- 객체 풀 패턴
  - 풀이라 불리는 객체의 집합체가 다른 컴포넌트에 사용되기 위해 준비된 상태로 유지된다.
  - 일반적으로 이 패턴은 커넥션 풀과 초기화 시간이 매우 중요한 명령어와 관계가 있다.
  - 데이터베이스 커넥션에서 자주 사용된다.

### 구조 패턴

- 관계를 위한 패턴과 컴포넌트간의 통신을 위한 패턴이 있다.
- 서드파티 모듈에 공통 인터페이스로서 ㅇ녀결하기 위해 사용된다.
- 적응자 패턴
  - 가장 일반적인 패턴으로, 서로 호환성이 없는 두 컴포넌트를 공통의 인터페이스로 연결하고자 할 때 사용된다.
  - 두 컴포넌트를 연결하고 있는 적응자는 어떠한 로직도 가지고 있지 않다.
  - 새로운 공통 인터페이스로의 연결을 위한 두개의 인터페이스만 허용한다.
  - 이 패턴은 두 개의 인터페이스가 있고 그 중 하나가 리팩토링이 필요해 메소드를 변경해야할 때 나타난다. 다른 하나는 리팩토링할 필요가 없기 때문에 적응차를 사용해 애플리케이션을 지속적으로 수행시킬 수 있다.
- 복합체 패턴
  - 객체의 그룹이나 단일 객체가 동일한 방식으로 다뤄지고 접근돼야 할 때 사용된다.
  - 이 패턴은 객체의 그룹이나 단일 객체에 접근해야할 때를 모르는 경우에 사용된다.
  - jQuery 가 대표적인 예시이다.
  - 사용자 입력에 유연하게 만드는 데 매우 효과적이다.
- 장식자 패턴
  - 동일 클래스에 있는 다른 객체의 행동에는 영향을 미치지 않으면서 특정 객체에 기능을 더하기 위해 사용된다.
  - 프로토타입적인 상속의 기반이 된다.
- 퍼사드 패턴
  - 복잡한 라이브러리를 사용하고 이해하기가 더 쉬운 인터페이스로 감쌀 때(래핑할 때) 사용된다.
  - 때때로 라이브러리는 다양한 옵션들을 통해 지나치게 다용도로 사용될 수 있지만, 이 패턴을 사용해 복잡한 라이브러리에 단순한 인터페이스를 사용함으로써 용도를 축소시켜주기도 한다.
- 프록시 패턴
  - 객체가 무언가에 접근하기 위한 프폭시 같은 역할을 하는 패턴을 말한다.
  - 접근 가능한 것들은 다른 객체일 수도 있고 파일, 폴더, 데이터베이스의 정보가 될 수 있다.
  - REST 인터페이스가 대표적인 예시이다.

### 행동 패턴

- 객체 간 통신 패턴을 구분하는 것으로 특징지을 수 있다.
- 중재자 패턴
  - 추상 계층을 만들어 다수 클래스 간의 통신을 처리한다.
  - 애플리케이션이 복잡해질수록, 클래스 간 통신의 복잡성을 낮추기 위한 중재자의 필요성이 대두된다.
  - 중재자는 객체가 서로 직접 상호작용하지 못하게 하는 것이다. 모든 클래스 간의 통신을 캡슐화하고, 상호 의존성을 낮추면서 결합도를 느슨하게 해준다.
- 템플릿 메소드 패턴
  - 옵션의 집합을 받고 정보를 컴파일하는 메소드로 돼 있고, 변경 가능한 부분은 플레이스홀더 상태로 남겨져 있다.
  - 국제화 문자열 등에 쓰인다.
- 감시자 패턴
  - 자식 객체의 목록을 유지하고 감시자를 호출해 각 자식 객체에서 제공하는 메소드를 호출하는 것으로 변화를 알려준다.
  - 이벤트 시스템이라고 부른다.
  - 메모리 누수와 같은 문제를 일으킬 수 있다.

## 이벤트 주도 아키텍처

- Node.js 로 개발하는 것은 단지 넓게 채택되거나 완전하게 지원되는 패턴들의 수에 차이가 있을 뿐이다.
- 애플리케이션 컴포넌트나 서비스의 결합도를 느슨하게 유지할 수 있기 때문에 다른 서비스에 영향을 주지 않으면서 개선할 수 있다.
- 발행-구독 패턴
  - 이벤트 주도 패턴의 변형이다.
  - 이벤트 대신 메시지를 사용하고 리스너 대신 구독자가 있으며 이벤트 에미터 대신 발행자가 있다.
  - 최대의 장점은 네트워크 계층을 사용하는 작업을 구현할 수 있다는 점이다.
  - 구독자가 메시지 속성을 기반으로 받길 원하는 종류의 메시지를 결정할 수 있다.

### 스트림

- 스트림은 이벤트 소비자에게 소비할 데이터가 있음과 데이터의 끝 지점을 알려주기 위해 이벤트를 사용한다.
- 읽기 기능
  - 파일 파서가 대표적인 예시이다.
  - 다른 유형의 스트림과 파이프로 연결될 수 있다.
- 쓰기 기능
  - 파일에 쓰기를 하거나 클라이언트에 응답하는 것들이 예시이다.
  - 압축(zlib), 암호화(crypto) 등이 있다.
  - 목적지에 데이터를 쓰고 이 과정을 알려준다.
  - 스트림에서 데이터를 메모리에 저장한다.
- 듀플렉스
  - 읽기 쓰기가 모두 가능한 스트림이다.
  - 소스와 목적지 양쪽을 처리한다.
  - 예) 소켓
- 트랜스폼
  - 듀플렉스의 확장이다.
  - 소스와 목적지 사이에 데이터 변형이 수행된다.
  - 예) 데이터 압축

### 버퍼

- 자바스크립트 문자열은 유니코드로 인코딩되기 때문에, 이진 데이터는 스크램블된 상태에서 처리된다.
- 클라이언트로의 파일 스트림이나 클라이언트로부터 파일을 받아 디스크로 쓰는 것은 모두 아주 간단한 스트림 사이의 파이프 연결이다.

## 최적화

- 최적화는 코드 구조에 특화된 패턴이다.
- 코드에서는 V8에 특성화된 최적화 방식을 사용해야 한다.

### 히든 타입

- 자바스크립트는 동적타입을 지원한다.
- 동적 타입은 컴파일 시간에 최적화하기 어렵다.
- 히든 타입은 V8 에서 동일 객체 간 최적화를 공유하는 기능이다.
- 개인 추가 내용
  - V8's hidden classes are internal constructs used to track the layout of JS objects in memory.
  - This tracking process is critical for the optimization of property access and can heavily influence the overall performance of JS code.
  - When a new object is created in JavaScript, the V8 engine doesn't *know* what shape it will take - what keys and values it will have.
  - As properties are added to the object, V8 creates a new hidden class for that object layout.
  - Adding properties to an object after instantiation, or adding properties to an object *out of order* can result in the generation of many hidden classes.
  - While manipulating objects seems flexible and easy at the surface level, understanding "hidden classes" can help developers write code that is more optimized for JavaScript execution engines.

### 배열

- 중간에 위치한 엘리먼트를 제거하거나 초기화하지 않은 엘리먼트에 접근하는 일은 피하자.

### 함수

- 함수는 객체로부터 상속받기 때문에 히든 타입이 적용된다.
- 다형 함수는 성능을 매우 저하시키는 요인이다.

### Try-Catch

- 컴파일러에서 `try-catch` 내부의 범위를 최적화하는 것이 어렵기 때문에 가능ㅎ란 많은 코드를 블록 밖으로 옮겨주는 것이 좋다.

# Ch. 03 가비지 컬렉션

- 가장 일반적인 기법은 참조 횟수를 모니터링하는 것이다.
- V8 에서는 참조 횟수가 계속적으로 확인되지 않는다.
- **사이클** 작업을 통해 주기적으로 살펴본다.
- 사이클 실행 중에는 프로그램이 멈추게된다.

## 자동 메모리 관리

- 허상 포인터 버그: 이미 메모리를 해제했지만, 해당 블록을 참조하고 있는 포인터가 남아있는 경우에 발생한다.
- 중복 할당 해제 버그: 이미 해제된 메모리를 다시 해제하려고 할 때 발생한다.
- 메모리 누수: 메모리가 해제되기 전에 객체 참조를 해제하면서 발생한다.
- 버퍼 오버플로우: 작업에 할당된 공간 이상의 데이터 쓰기를 시도할 때 발생한다.
- `--expose_gc` 플래그를 사용하면 `gc()` 메소드를 사용할 수 있다.
  - 정확한 시점은 결정할 수 없지만, 더 자주 강제적으로 수행할 수는 있다.

### 메모리 조직

- 메모리를 기본형(숫자와 문자열)과 객체(해시 테이블)로 돼 있는 엘리먼트 그물망으로 생각하자.
- A 노드에서 B 를 거쳐 C 노드로 참조될 경우, B 노드에 대한 참조가 해제되면 C 노드도 함께 제거된다.

### 메모리 누수

- 메모리 누수는 계속해서 가용 메모리가 감소되는 것을 의미한다.
- 메모리를 해제하는데 반복적으로 실패할 때 발생한다.

### 이벤트 에미터

- GC 는 참조되지 않는 객체만을 정리하기 때문에 이벤트 에미터는 리스너가 사용된 이후에 GC 에 의해 정리되지 않는다.

### 객체 참조

- GC 는 참조 해제된 객체를 표시하고, 정리한 후, 빈 공간을 없앤다.
- V8 이전의 GC 는 old 영역을 정리하기 위해 mark-sweep 과 mark-compact 라는 두 가지 알고리즘을 가지고 있었다.
- V8 GC 는 지연 스윕 (lazy sweep) 을 수행한다.

### 객체 힙

- GC 는 객체 힙에 객체를 저장한다.
- 힙은 **old** 와 **new** 영역으로 나뉜다.
- old 영역은 한 번 이상의 GC 사이클 이후에도 남아있는 객체들이 옮겨지는 공간이다.
